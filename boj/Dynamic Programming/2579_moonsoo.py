import sys

input= sys.stdin.readline

"""
문제:
계단 오르는 데는 다음과 같은 규칙이 있다.

계단은 한 번에 한 계단씩 또는 두 계단씩 오를 수 있다. 즉, 한 계단을 밟으면서 이어서 다음 계단이나, 다음 다음 계단으로 오를 수 있다.
연속된 세 개의 계단을 모두 밟아서는 안 된다. 단, 시작점은 계단에 포함되지 않는다.
마지막 도착 계단은 반드시 밟아야 한다.
따라서 첫 번째 계단을 밟고 이어 두 번째 계단이나, 세 번째 계단으로 오를 수 있다. 
하지만, 첫 번째 계단을 밟고 이어 네 번째 계단으로 올라가거나, 첫 번째, 두 번째, 세 번째 계단을 연속해서 모두 밟을 수는 없다.

각 계단에 쓰여 있는 점수가 주어질 때 이 게임에서 얻을 수 있는 총 점수의 최댓값을 구하는 프로그램을 작성하시오.


입력의 첫째 줄에 계단의 개수가 주어진다.
둘째 줄부터 한 줄에 하나씩 제일 아래에 놓인 계단부터 순서대로 각 계단에 쓰여 있는 점수가 주어진다. 
계단의 개수는 300이하의 자연수, 계단에 쓰여 있는 점수는 10,000이하의 자연수.
____________________________________________________________________________________________________________________________
풀이:

이 문제의 어려웠던 점은 dp[N]을 구하기 위해 앞선 것들을 조회하고 싶지만 dp[N-1], dp[N-2] 등이 N에 따라 매번 바뀐다는 것이다.
즉, dp 배열의 값이 계속해서 바뀌므로 일반적으로 사용할 수가 없다.
이는 3번 연속해서 계단을 밟을 수 없는 성질때문인데, 예를 들어 dp[N-1]이 두 계단을 연속해서 밟는 게 최대값이었다면
dp[N]은 dp[N-1]을 아예 고려조차 못하게 되는 것이다. 
따라서 dp[N-1]의 값을 마지막 두 계단이 연속되지 않으면서 최대인 값으로 바꿔줘야 하고 고려해야 할 사항이 많아지며 복잡해진다.

이를 해결하기 위해서 나는 2차원 배열을 사용해 연속으로 밟은 계단의 수를 포함해주었다.
자세한 내용은 아래와 같다.
예를 들어, dp[3][1], dp[3][2]와 같이하여 각각 세 번째 계단을 밟을 때 연속없이 한 번인 경우(1->3), 직전 계단과 해당 계단을 밟아 2번 연속된 경우이다(2->3).
세 번 연속 밟는 경우는 불가하므로 dp[N][3]은 고려할 필요가 없다.
(이 때, 편의를 위해 0번 컬럼은 고려하지 않고 1과 2컬럼을 사용하였다.)

수식으로 나타내면 다음과 같다.
dp[N][1] = max(dp[N-2][1], dp[N-2][2]) + stair[N]       ... 한 칸 띄워야 하므로 N-2번 계단의 값들 중 최대와 현재 계단의 값을 더한다.
dp[N][2] = dp[N-1][1] + stair[N]                        ... 두 칸 연속이어야 하므로 dp[N-1][2]는 사용할 수 없다.
(N >= 2, N=1은 할당 필요)


백준 예시와 함께 알아보자.

           연속된 계단 수 
계단 값|n     1      2
------------------------
10    |1     10     0
20    |2     20     30
15    |3     25     35
25    |4     55     50
10    |5     45     65
20    |6     75     65

와 같이 테이블이 나온다.
결론적으로 dp[N]은 max(dp[N][1], dp[N][2]) 출력해주면 된다!
"""

stair = [0] * 301

N = int(input())
for i in range(1, N+1):
    score = int(input())
    stair[i] = score
# 계단 별 점수 입력

dp = [[0 for j in range(3)] for i in range(301)]
dp[1][1] = stair[1]

for n in range(2, N+1):
    dp[n][1] = max(dp[n-2][1], dp[n-2][2]) + stair[n]
    dp[n][2] = dp[n-1][1] + stair[n]

print(max(dp[N][1], dp[N][2]))