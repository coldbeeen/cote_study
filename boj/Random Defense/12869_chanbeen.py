n = int(input())

scv = list(map(int, input().split()))

scv.extend([0, 0]) #3개 미만이 들어왔을 때 개수 맞춰주기

dp = [[[0]*61 for _ in range(61)] for _ in range(61)] #각 위치에 도달하는 횟수 저장
dp[scv[0]][scv[1]][scv[2]] = 1 #초기화, 0인데 1로 초기화했으므로 나중에 1 빼주기

comb = [(9, 3, 1), (9, 1, 3), (3, 9, 1), (3, 1, 9), (1, 9, 3), (1, 3, 9)] #경우의 수 설정
for i in range(60, -1, -1):
    for j in range(60, -1, -1):
        for k in range(60, -1, -1):
            if dp[i][j][k] > 0:
                for c in comb:
                    i_ = i-c[0] if i-c[0] >= 0 else 0
                    j_ = j-c[1] if j-c[1] >= 0 else 0
                    k_ = k-c[2] if k-c[2] >= 0 else 0
                    if dp[i_][j_][k_] == 0 or dp[i_][j_][k_] > dp[i][j][k]+1:
                    # 처음 도착한 경우 or 더 적은 횟수로 도착하는 경우에만 업데이트
                        dp[i_][j_][k_] = dp[i][j][k]+1

print(dp[0][0][0]-1)

#힙 정렬 구조를 사용해서 큰 수부터 큰 데미지를 주려고 시도
#이렇게는 풀리지 않는 경우의 수가 존재
#최적의 경우의 수를 찾으려면 DP로 풀어야할 것 같다

#DP 예제 중 화폐 구성 문제와 유사하지 않을까?

#체력이 0으로 딱 떨어지지 않는 경우도 존재하므로, 화폐 구성 문제처럼은 풀 수 없다

#scv가 3개가 있으니까, 3중 DP를 써야할 것 같다
#데미지도 모든 경우에서 조사해봐야 할 것 같다
#=> 4중 반복문, 이게 맞나?