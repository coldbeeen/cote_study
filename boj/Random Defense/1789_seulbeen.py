# 수들의 합
# 35분
"""
서로 다른 N개의 자연수 합이 S일때, 주어진 S에 대한 N의 최댓값
N이 최대-> 숫자를 많이 써야함 -> 작은것 부터?
dp일거같은 삘이 왔다!
아 근데 중복이 안되니까 dp는 아닐듯...

* 그렇다면 그냥 S에서 1부터 빼자, 언제까지? S가 0보다 작아지는 순간의 직전까지!
그러면 1부터 x까지의 연속된 자연수들의 합으로 구성된 's보다 작은 임의의 수 y'가 나올것
s와 y의 차이만큼 큰수에서부터 1씩 키워서 메꿔주면 됨

ex) 200
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
총합이 210
20 빼면, 190
나머지 10을 다른 곳에서(큰곳에서부터 1씩 키워서) 메꾸면 됨
[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,]
"""
import sys
input=sys.stdin.readline
s=int(input())
tmp=s
# s가 1이 들어올때를 대비해서 0으로 스타트
n=0
nums=[]
total=0

# tmp가 0보다 작을때 까지 빼가면서 nums에 append
while 0<tmp:
    tmp-=n
    nums.append(n)
    total+=n
    n+=1
# 마지막 nums의 원소(s를 0보다 작게 만든 숫자)에 대한 복구작업(?)
total-=nums[-1]
nums.pop()

# nums의 마지막 숫자(제일 큰 수) 부터 역순으로 1씩 늘려감
idx=len(nums)-1
#횟수는 s와의 차이만큼 1씩 더하면 메꿔짐
for _ in range(s-total):
    nums[idx]+=1
    idx-=1

#만약 메꾸는 작업이 0까지 안왔다면(0에다가 1을 더하는 상황이 안나온다면) 0제거
try:
    nums.remove(0)
except:
    pass
print(len(nums))
