import sys

input = sys.stdin.readline

T = int(input())

def DFS(idx, cnt): #지목한 노드를 향해 재귀호출하는 방식
    for v in graph[idx]:
        if check[v] == 0: 
            check[v] = cnt
            cnt += 1 #점점 카운트 값이 하나씩 늘어나게
            DFS(v, cnt) 
        #방문한 적 없을 때만 체크 값을 변경하고 DFS를 돌아야, 주경이가 싸이클 안에 있을 때도 최소 cnt값으로만 체크 배열에 저장됨
        #if문 밖에서 DFS 재귀 호출하니 무한 루프 걸림(끝없이 지목하게 되는 것이므로 당연한 현상)

for _ in range(T):
    N = int(input())
    
    graph = [[] for _ in range(N + 1)] #이코테 강의처럼 재현
    for i in range(1, N + 1):
        v = int(input()) #한 리스트당 원소 하나만 들어가니까 상관없음
        graph[i].append(v) #이렇게 그래프 만드는 법 구글링했음
    
    check = [0] * (N + 1) #편하게 1번째 인덱스부터 쓰자
    
    DFS(1, 1)
    
    if check[N] > 0: #주경이가 누군가에게 지목당한 적이 있다면
        print(check[N])
    else:
        print(0)
#전략
#1. 더 게임 오브 데스, 우리가 아는 그 게임이다
#2. 특정한 사람들끼리 서로를 지목해서 사이클이 형성되면, 무조건 그 중에서 한 명이 걸린다
#3. 그 특정한 사람 중에 주경이가 없다면, 주경이는 걸릴 수가 없다
#4. 따라서 체크 배열 하나 만들어서, 그 사람이 누구 지목했는지 재귀 호출하면서 따라가면 된다
#4-1. 이렇게 하면 만약 주경이가 지목되지 않았다면 체크 배열의 값이 0일 것이다

#추가
#인접한 노드들을 리스트로 만들어 놓을 수 있게 처음에 그래프 변수 선언 시 2차원 리스트로 선언하는 게 좋다