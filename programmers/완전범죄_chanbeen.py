#70분 +@, 구글링

def solution(info, n, m):
    dp = [[False] * m for _ in range(n)] #dp의 각 칸의 인덱스는 A, B의 누적 흔적 개수를 의미함
    dp[0][0] = True #초기 A, B의 누적 흔적 개수는 모두 0개
        
    for aVal, bVal in info: #물건을 순서대로 훔쳐가면서 가능한 경우 계산
        next_dp = [[False] * m for _ in range(n)] #A 또는 B가 해당 물건을 훔칠 경우를 2차원 리스트로 관리
            
        for a in range(n):
            for b in range(m):
                if dp[a][b]: #이전 물건에 대해 진행된 시나리오에서만 진행되도록 하기 위한 조건문
                    if a + aVal < n: #A가 현재 물건을 훔치는 게 가능한 경우
                        next_dp[a + aVal][b] = True
                    if b + bVal < m: #B가 현재 물건을 훔치는 게 가능한 경우
                        next_dp[a][b + bVal] = True
            
        dp = next_dp #처음부터 현재 물건까지 훔치는 경우의 수를 담는 배열을 업데이트
        
    answer = 1e9
    
    for a in range(n): #마지막으로 갱신된 dp는 마지막 물건까지 훔치는 경우의 수가 진행된 상태
        for b in range(m):
            if dp[a][b]:
                answer = min(answer, a) #모든 물건을 훔치는 게 가능한 경우 중 A가 가장 흔적이 적을 때
        
    return answer if answer != 1e9 else -1

#0번째 인덱스는 A, 1번째 인덱스는 B에 대한 정보
#누적 흔적 개수 계산 - n개 이상이면 A 검거, m개 이상이면 B 검거
#A 도둑이 남긴 흔적의 최솟값 구하기
#B 도둑이 최대한 많이 훔쳐야 함, 특히 A가 흔적을 많이 남기는 물건 위주로
#해당 로직으로 구현해도 A의 흔적이 n이 넘는다면 -1 return
#A가 흔적을 많이 남기는 물건 순서로 정렬, B가 m이 넘지 않을 때까지 물건 훔치기

#정렬은 풀이 방식이 아닌듯함. 훔칠 수 있는 모든 경우를 구하는 완전 탐색 방법으로 변경
#백트래킹 방식으로 풀려고 했으나, 테스트 5번부터 시간 초과 발생

#구글링
#2^40은 불가능한 것, DP 방식으로 접근해서 풀어야 함
#기본 2차원 배열에, 모든 물건에 대한 모든 훔치는 시나리오를 하나의 변수에 다 담고 싶다면 3차원 배열을 활용해서 풀어야 함
#dp의 각 원소를 A, B가 남긴 누적 흔적이 안전 범위일 때 True, 기본 False로 유지
#이후 2차원 dp라면 현재 물건에 대한 경우의 수 계산이 끝난 뒤 dp를 업데이트
#마지막 물건까지 업데이트하면, True인 곳은 모든 물건을 훔치는 게 가능한 경우의 수

#DP는 언제나 벽을 느끼게 되는 유형