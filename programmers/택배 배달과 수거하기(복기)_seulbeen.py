# 1시간 32분
"""
1 0 3 1 2
0 3 0 4 0

1. 5번가서 2개 배달 (가는길에 4번에서 1개 배달), 4번에서 4개 수거(10)
# 1 0 3 0 0
# 0 3 0 0 0
2. 3번 가서 3개 배달, 2번에서 3개 수거(가는길에 1번에서 배달가능)(6)
"""


def solution(cap, n, deliveries, pickups):
    answer = 0
    # 배달과 픽업을 해야하는 물건
    rd, rp = 0, 0
    # 거꾸로 탐색
    for i in range(n - 1, -1, -1):
        
        cnt = 0
        # 해당 지점에서 배달/픽업해야하는 물건개수만큼 더함
        rd += deliveries[i]
        rp += pickups[i]
        
        # cap 만큼 배달/픽업이 가능하니, 그만큼 빼주는데, 예를 들어 cap=3이고, 연산 결과가 rd=-2라면, 이번턴에 다음 반복문 배달까지 커버치는거 ㅇㅇ(다음 포문에 2개 여유 생기는거)
        # 반복문 탈출조건 -> rd<=0 and rp<=0
        while rd > 0 or rp > 0:
            rd -= cap
            rp -= cap
            # 해당 지점까지 몇번을 왔다가야 하는지?
            cnt += 1

        # 출력해보면, 소요거리가 나옴
        # print(cnt*(i+1))
        answer += cnt * (i + 1) * 2
        # 이때, 왕복이므로 X2를 해줘야됨
    return answer


"""
가까운데 부터 계산하는것은 비효율적이라고 판단
-가면서 배달과 수거를 동시에 하면서 왔다갔다하는 것이 아니라, 갈때 배달하고 올때 수거를 담당하면됨
-왜냐하면, 가는길에 배달을 n만큼 했다면, 어차피 돌아가야 하니 왔던길로 돌아가는 길에 n보다 작은 거리에 있는 집에서 수거해가면됨, 즉 배달과 수거는 독립적
그렇다면 한번 가는김에 먼곳부터 가야함 -> 거꾸로탐색
"""
