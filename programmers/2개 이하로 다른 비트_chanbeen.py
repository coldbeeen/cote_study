#60분 +@, 구글링

def solution(numbers):
    answer = []

    for number in numbers:
        bin_number = list('0' + bin(number)[2:]) #2의 경우 '0b10' return, 따라서 2번째 인덱스부터 사용
        
        idx = ''.join(bin_number).rfind('0') #오른쪽에서 출발하여 '0'을 발견했을 때 해당 인덱스를 반환
        
        bin_number[idx] = '1'
        
        if number % 2 == 1: #홀수일 때 추가 변환 (하단 해설 참고)
            bin_number[idx + 1] = '0'
        
        answer.append(int(''.join(bin_number), 2)) #int(string, 2)는 2진수 문자열을 10진수로 변환

    return answer

#1차 제출
#길이 제한 10만, O(n^2)까지는 괜찮을 듯
#특정 숫자 n보다 크면서 비트가 다른 지점이 2개 이하이면서 제일 작은 수
#n이 0111이면 1011이 해당 조건을 만족하는 방식
#n부터 이후의 수를 비트로 바꾸면서, 비트를 비교하여 다른 비트의 개수가 2개 이하라면 바로 return
#로직은 알맞게 구현했으나, 시간초과 발생
#numbers for문 + While True + O(N) 알고리즘이 겹쳐져 시간초과가 발생한 듯
#숫자를 하나씩 키우며 비트 변한 및 비교를 하는 과정을 채택하기엔 시간 효율성 측면에서 무리가 있어보인다

#구글링
#파이썬에는 이진수 변환 함수(bin), 십진수 변환 함수( int(string, 2) )가 존재한다
#오른쪽에서 왼쪽으로 순회한다고 가정할 때,
#짝수의 경우에는 가장 먼저 등장하는 0을 1로 교체
#홀수의 경우에는 가장 먼저 등장하는 0을 1로 교체, 교체한 인덱스 바로 오른쪽 인덱스를 0으로 교체
#이 방법이 가장 작은 수를 만들 수 있는 방법

#이런 참신한 풀이방법이 필요한 문제에서는 항상 벽을 느끼는 것 같다